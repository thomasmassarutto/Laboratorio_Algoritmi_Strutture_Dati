---
title: "Periodo frazionario"
author: "Bozza"
date: "2023-08-17"
output:
  #pdf_document: 
  #fig_crop: false
  word_document:
  fig_crop: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE, fig.align = 'center')
```

```{r functions, include=FALSE}
##
## raccolta di funzioni utili
##

library(ggplot2)
library(dplyr)
library(grid)
library(gridExtra)
results <-read.csv("results.csv")

## plotta una singola run 
smallPlotRun<-function(idRun){
  
  runDataSet= filter(results,Run == idRun)
  
  # Creazione del grafico a pallini
  ggplot(runDataSet, 
         aes(x = String.Length, 
             y = Duration, 
             color = Algorithm.Type)) +
    
    geom_point() +
    
    scale_color_manual(values = c("naive" = "red", 
                                  "smart" = "blue")) +
    
    scale_y_continuous(labels = scales::label_number(scale = 1e-6, suffix = "M"),
                       name = "Nanosecondi") +
    
    scale_x_continuous(labels = scales::label_number(scale = 1e-3, suffix = "K"),
                       name = "Lunghezza stringa") +
    
    theme(legend.position="none")
  
}
#####

## Calcola la media delle run
## ritorna dataset con 2 colonne: string.Length, Duration
## Duration è la media delle run
average <-function(algo){
  # Filtra i risultati per l'algoritmo "naive"
  algo_results <- results %>%
    filter(Algorithm.Type == algo)
  
  # Imposta l'opzione per la notazione esponenziale
  options(scipen = 999)
  
  # Raggruppa per lunghezza della stringa e calcola la media della durata
  average_duration_by_length <- algo_results %>%
    group_by(String.Length) %>%
    summarise(Duration = mean(Duration))
  
  return (average_duration_by_length)
}
#####

```
# Periodo frazionario

## Scopo del progetto

Lo scopo di questo progetto è implementare due algoritmi per il calcolo del _periodo frazionario minimo_ di una stringa e misurarne i tempi medi di esecuzione. Per _periodo frazionario minimo_ si intende, data una stringa _S_, la lunghezza (_p_) della sottostringa più breve che può essere ripetuta in modo da formare la stringa _S_. Deve quindi soddisfare la seguente proprietà:

$$s(i)=s(i+p) \quad \forall i= 1, \dots , n-p$$

- $s$: stringa
- $p$: lunghezza del periodo
- $n$: lunghezza della stringa
- $i$: parte esterna al periodo frazionario

## Algoritmi e fondamenti teorici

### PeriodNaive

_PeriodNaive_ è un algoritmo di complessità $O(n^2)$ che, mediante un ciclo _for_, itera su di una stringa, e ne analizza ogni possibile periodo. Partendo da un periodo di lunghezza _p=1_ e incrementando di uno ogni volta il valore, la stringa viene suddivisa in due parti: _head_ e _tail_. Quando queste coincidono l'esecuzione termina e viene restituita la lunghezza finale _p_.

```
Funzione periodoNaive(Stringa):
	Length= lunghezza(Stringa)
	ITERA P da 1 fino Length{
		Head= sottostringa(Stringa, 0 -> Length-P )
		Hail= sottostringa(Stringa, P -> Length)

		SE Head è uguale a Tail:
			RESTITUISCI P
	}
```

#### Calcolo di correttezza

#### Calcolo di complessità

| Codice                                                 | Costo  | Volte |
| ------------------------------------------------------ | ------ | ----- |
| `public  static  int  periodNaive(String  stringa) { ` |        |
| `int  n= stringa.length();`                            | $O(1)$ | 1     |
| `for (int  p=1; p<=n;p++){`                            |        |
| `String  head=stringa.substring(0, n-p);`              | $O(n)$ | n     |
| `String  tail=stringa.substring(p, n);`                | $O(n)$ | n     |
| `if (head.equals(tail)){`                              | $O(p)$ | n     |
| `return  p;`                                           | $O(1)$ | 1     |
| `}`                                                    |        |
| `}`                                                    |        |
| `return  ERR;`                                         |        |
| `}`                                                    |        |

Dalla tabella risulta che il costo computazionale dell'algoritmo è:

$$
\begin {aligned}
Costo &= O(1) + O(n) \cdot n + O(n) \cdot n +O(p) \cdot n +O(1)\\
 &=n \cdot ( 2 \cdot O(n) +O(p) ) + 2 \cdot O(1)\\
 &\simeq O(n^2)
 \end {aligned}
$$

### PeriodSmart

_PeriodSmart_ è un algoritmo di complessità $O(n)$ che utilizza il concetto di _bordo_ per calcolare la lunghezza del _periodo frazionario minimo_. Genera un _array_ per memorizzare la lunghezza dei bordi delle sottostringhe (`r[i]` è il bordo della sottostringa che termina in posizione `i - 1`) e poi _itera_ sulla stringa cercando per ogni carattere un bordo fra i caratteri precedenti. Se il carattere corrente coincide col bordo, incrementa la lunghezza del bordo, altrimenti la riduce cercando un bordo più corto. Il periodo frazionario minimo è dato dalla lunghezza della stringa meno la lunghezza massima del bordo.

```
Funzione periodSmart(S: stringa):
    N = lunghezza(s)
    R = array di interi di dimensione n + 1
    R[1] = 0
    ITERA I da 2 fino a N:
        J = R[I - 1]
        FINCHE 	J > 0,
		        carattere in (i - 1) di S != dal carattere in posizione J di S:
            J = R[J]
        SE carattere in (I - 1) di S == al carattere in J di s:
            R[I] = J + 1
        ALTRIMENTI:
            R[I] = 0
    MaxBordo = R[N]
    PeriodoFrazionario = N - MaxBordo
    RESTITUISCI PeriodoFrazionario
```

#### Calcolo di correttezza

#### Calcolo di complessità

| Codice                                              | Costo  | Volte |
| --------------------------------------------------- | ------ | ----- |
| `public  static  int  periodSmart(String  s) {`     |        |
| `int  n = s.length();`                              | $O(1)$ | 1     |
| `int[] r = new  int[n + 1];`                        | $O(1)$ | 1     |
| `r[1] = 0;`                                         | $O(1)$ | 1     |
| `for (int  i = 2; i <= n; i++) {`                   |        |
| `int  j = r[i - 1];`                                | $O(1)$ | n     |
| `while (j > 0 && s.charAt(i - 1) != s.charAt(j)) {` | $O(2)$ | n     |
| `j = r[j];`                                         | $O(1)$ | n     |
| `}`                                                 |        |
| `if (s.charAt(i - 1) == s.charAt(j)) {`             | $O(1)$ | n     |
| `r[i] = j + 1;`                                     | $O(1)$ | n     |
| `} else {`                                          |        |
| `r[i] = 0;`                                         | $O(1)$ | n     |
| `}}`                                                |        |
| `int  maxBordo = r[n];`                             | $O(1)$ | 1     |
| `int  periodoFrazionario = n - maxBordo;`           | $O(1)$ | 1     |
| `return  periodoFrazionario;`                       | $O(1)$ | 1     |
| `}`                                                 |        |

Dalla tabella risulta che il costo computazionale dell'algoritmo è:

$$
\begin {aligned}
Costo &= O(1) + O(1) + O(1) + O(1) \cdot n + O(2) \cdot n + O(1) \cdot n + O(1) \cdot n + O(1) \cdot n + O(1) \cdot n  + O(1) + O(1) + O(1) \\
 &= 6 \cdot O(1) + n \cdot O(1) + O(2)\\
 &\simeq O(n)
 \end {aligned}
$$

## Analisi delle prestazioni

Per valutare le prestazioni degli algoritmi in maniera empirica si è deciso di realizzare un programma Java in grado di misurare i tempi medi di esecuzione degli algoritmi. Il progetto si suddivide in 5 classi:

- **Progetto**: classe principale che contiene i passaggi per testare, cronometrare e ricavare dati utili in fase di analisi.
- **Algos**: contiene l'implementazione degli algoritmi per il calcolo del periodo frazionario minimo di una stringa.
- **Chrono**: fornisce meccanismi di cronometraggio necessari per misurare il tempo di esecuzione del programma e la stima di risoluzione del clock di sistema in nanosecondi.
- **Logger**: gestisce la registrazione delle informazioni rilevanti su un file .csv.
- **StringGenerator**: genera stringhe casuali con varie lunghezze comprese fra 1000 e 500000. Queste hanno una distribuzione esponenziale e sono basate su un alfabeto ternario: _a_, _b_, _c_.

### Metodologia di test

Una volta calcolato il _tempo minimo misurabile_, per ricavare dati attendibili sono state eseguite 6 run da 100 iterazioni ciascuna. Ad ogni iterazione una stringa generata casualmente, e progressivamente sempre più lunga, è stata fornita in input ad entrambi gli algoritmi. È stato utilizzato un ciclo _while_ per iterare l'esecuzione dell'algoritmo e misurare il tempo trascorso, fino a quando tale tempo non è risultato superiore al _tempo minimo misurabile_. Il _tempo medio di esecuzione_ per una singola istanza di input è stato calcolato come il rapporto fra il tempo trascorso e il numero di iterazioni "_while_" eseguite.

```
Progetto main():
	t_min= tempo_minimo_misurabile()
	ITERA Run da 1 a 5{
		ITERA Tedt da 0 a 99{
			stringa= generatringa()
			//testa algoritmo 1
			iterazione= 0
			start= now()
			FAI{
				algoritmo(stringa)
				end= now()
				iterazione++
			}FINCHÈ (end-start< tmin)
			tempo_medio= (end-start)/i
			// testa algoritmo 2
			...
		}
	}
```
### Risultati sperimentali di vari test

Analizzando i grafici _Durata_ vs _Lunghezza della stringa_ si nota come, i tempi di risoluzione relativi all'algoritmo _PeriodNaive_ crescono esponenzialmente, mentre,  quelli relativi a _PeriodSmart_ hanno una crescita lineare.


```{r 6runs , echo=FALSE}
##
## plot delle 5 run di raccolta dati eseguite
##
run1<- smallPlotRun(1)
run2<- smallPlotRun(2)
run3<- smallPlotRun(3)
run4<- smallPlotRun(4)
run5<- smallPlotRun(5)
run6<- smallPlotRun(6)




grid.arrange(run1, run2, run3, run4, run5, run6, 
             ncol = 2, nrow = 3, 
             top=textGrob("Durata vs Lunghezza della stringa"))


```

Sin dalle prime iterazioni il delta temporale fra i due algoritmi è dell'ordine di qualche millisecondo. Questa questa differenza aumenta esponenzialmente raggiungendo oltre mezzo secondo nelle iterazioni finali.


```{r averagerun,  fig.width=6, echo=FALSE}
naive <- average("naive")
smart <- average("smart")

# Aggiungi le informazioni calcolate al dataset "results"
results <- bind_rows(
  results,
  mutate(naive, 
         Algorithm.Type =  "naive",
         Fractional.Period = NA,
         Run = 0)
)

results <- bind_rows(
  results,
  mutate(smart, 
         Algorithm.Type =  "smart",
         Fractional.Period = NA,
         Run = 0)
)

## plotta la media
average_results <- filter(results, Run == 0)
ggplot(average_results, 
       aes(x = String.Length, 
           y = Duration, 
           color = Algorithm.Type)) +
  
  geom_point() +
  
  scale_color_manual(values = c("naive" = "red", 
                                "smart" = "blue")) +
  
  scale_x_log10() +  # Scala logaritmica sull'asse x
  scale_y_log10() +  # Scala logaritmica sull'asse y
  
  labs(title = "Durata vs Lunghezza della stringa (scala logaritmica)",
       x= "Lunghezza della stringa (caratteri)",
       y="Durata (nanosecondi)",
       color = "Algoritmo")
```

Basandosi sui dati raccolti, è possibile creare un modello in grado di prevedere l'andamento temporale dei due algoritmi. In particolare l'evoluzione del modello Naive può essere descritta da un'equazione di secondo grado:


$$
y_{naive} = 565335.910 + 142.414 \cdot x + 0.146 \cdot x^2
$$


La validità del modello è supportata dagli indici statistici, in particolare il _Residual Standard Error_ indica come l'errore standard dei residui sia di circa 13.73 millisecondi. Gli indici _Multiple R-squared_ e _Adjusted R-squared_, atti a spiegare la variabilità dei dati,hanno totalizzato il valore massimo di 1. Infine il _p-value_ è di gran lunga inferiore alla soglia di 0.05 ($2,2 \times 10^{-16}$), il che indica un risultato statisticamente significativo.


```{r previsionsNaive , echo=FALSE}

naiveRegression= lm(Duration ~ poly(String.Length, 2, raw=TRUE), data = naive )
naiveRegressionSummary=summary(naiveRegression)
coefficenti_naive<-coef(naiveRegression)

ggplot(naive, 
       aes(x = String.Length, 
           y = Duration
       )) +
  
  geom_point(color='red') +
  
stat_smooth( method = "lm", 
             formula = y ~ poly(x, 2, raw = TRUE), 
             se=TRUE, fill=NA,
              colour="black"
             )+

  labs(title = "Durata vs Lunghezza della stringa Naive",
       x= "Lunghezza della stringa",
       y="Durata (nanosecondi)"
  )

```

L'evoluzione del modello Smart può essere, invece, descritta da un'equazione di primo grado:
$$
y_{smart} = 10679.087 +  6.607 \cdot x
$$

Anche in questo caso la validità del modello è supportata dagli indici statistici, in particolare il _Residual Standard Error_ indica come l'errore standard dei residui sia di circa 0,0448 millisecondi. Gli indici _Multiple R-squared_ e _Adjusted R-squared_,hanno totalizzato il valore quasi massimo di 0.9969. Infine il _p-value_ è di gran lunga inferiore alla soglia di 0.05 ($2,2 \times 10^{-16}$), il che indica un risultato statisticamente significativo.


```{r previsionssmart , echo=FALSE}

smartRegression=lm(Duration ~ String.Length, data = smart)
smartRegressionSummary= summary(smartRegression)
coefficenti_smart<-coef(smartRegression)

ggplot(smart, 
       aes(x = String.Length, 
           y = Duration
       )) +
  
  geom_point(color='blue') +
  
  geom_smooth(method = "lm",formula = "y ~ x", se = FALSE, color = "black") + 
  
  labs(title = "Durata vs Lunghezza della stringa Smart",
       x= "Lunghezza della stringa",
       y="Durata (nanosecondi)"
  )


```